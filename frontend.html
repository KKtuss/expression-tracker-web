<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expression Tracker Web</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #000000;
            color: #00ff00;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            gap: 15px;
            padding: 15px;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .top-panels {
            display: flex;
            gap: 15px;
            flex: 2;
            min-height: 0;
        }
        
        .bottom-panels {
            display: flex;
            gap: 15px;
            flex: 1;
            min-height: 0;
        }
        
        .left-panel {
            flex: 1.3;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 0;
        }
        
        .right-panel {
            flex: 0.7;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 0;
        }
        
        .camera-section {
            background: #000000;
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 0;
            flex: 1;
            display: flex;
            flex-direction: row;
            gap: 15px;
            min-height: 0;
            align-items: flex-start;
        }
        
        .camera-feed-container {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 0;
            max-width: 60%;
            max-height: 100%;
            overflow: hidden;
        }
        
        .camera-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .overlay-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            z-index: 10;
        }
        
        .camera-debug {
            flex: 1;
            overflow-y: auto;
            min-width: 200px;
        }
        
        .image-display {
            background: #000000;
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 0;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }
        
        .debug-section {
            background: #000000;
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 0;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }
        
        .controls-section {
            background: #000000;
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 0;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }
        
        .expression-section {
            background: #000000;
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 0;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow-y: auto;
        }
        
        video, img {
            max-width: 100%;
            border: 1px solid #00ff00;
        }
        
        .camera-feed {
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 80vh;
            object-fit: contain;
            background: #000000;
            transform: scaleX(-1); /* Mirror the camera feed */
            border: 1px solid #00ff00;
        }
        
        .expression-image {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            background: #000000;
        }
        
        button {
            background: #000000;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 10px 20px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 14px;
            margin: 5px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #00ff00;
            color: #000000;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button:disabled:hover {
            background: #000000;
            color: #00ff00;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-button {
            background: #000000;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px 10px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 12px;
            margin: 2px;
            transition: all 0.2s;
        }
        
        .file-button:hover {
            background: #00ff00;
            color: #000000;
        }
        
        .status {
            font-size: 12px;
            padding: 5px;
            margin: 5px 0;
            border: 1px solid #00ff00;
            background: #000000;
        }
        
        .status.success {
            border-color: #00ff00;
        }
        
        .status.error {
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .status.warning {
            border-color: #ffff00;
            color: #ffff00;
        }
        
        .category-header {
            background: #00ff00;
            color: #000000;
            padding: 8px 12px;
            margin: 10px 0 5px 0;
            font-weight: bold;
            font-size: 14px;
            border-radius: 3px;
            text-align: center;
        }
        
        .expression-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            border-bottom: 1px solid #00ff00;
            margin-bottom: 5px;
        }
        
        .expression-item:last-child {
            border-bottom: none;
        }
        
        .expression-name {
            min-width: 100px;
            font-size: 12px;
        }
        
        .expression-status {
            font-size: 10px;
            padding: 2px 5px;
            border: 1px solid #00ff00;
            background: #000000;
        }
        
        .debug-info {
            font-family: Arial, sans-serif;
            font-size: 11px;
            line-height: 1.4;
            white-space: pre-wrap;
        }
        
        .section-title {
            font-size: 16px;
            margin-bottom: 10px;
            border-bottom: 1px solid #00ff00;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .filter-toggle {
            background: #00ff00;
            color: #000000;
            border: none;
            padding: 4px 8px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
        }
        
        .filter-toggle:hover {
            background: #00cc00;
        }
        
        .controls-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .clear-button {
            background: #000000;
            color: #ff0000;
            border: 1px solid #ff0000;
        }
        
        .clear-button:hover {
            background: #ff0000;
            color: #000000;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Panels: Camera (left) + Image Display (right) -->
        <div class="top-panels">
            <!-- Left Panel: Camera Feed with Debug -->
            <div class="left-panel">
                <!-- Camera Section -->
                <div class="camera-section">
                <div class="camera-feed-container">
                    <div class="section-title">CAMERA FEED</div>
                    <div class="camera-wrapper">
                        <video id="videoElement" class="camera-feed" autoplay muted></video>
                        <img id="overlayElement" class="overlay-feed" src="" alt="Detection overlay">
                    </div>
                    <div class="controls-row">
                        <button id="startCameraBtn">START CAMERA</button>
                        <button id="startDetectionBtn" disabled>START DETECTION</button>
                        <button id="stopDetectionBtn" disabled>STOP DETECTION</button>
                        <button id="toggleOverlayBtn">SHOW OVERLAY</button>
                    </div>
                    <div id="statusElement" class="status">Ready</div>
                    <div id="viewMode" class="status">Raw Camera</div>
                </div>
                    
                    <!-- Debug Section -->
                    <div class="camera-debug">
                        <div class="section-title">DEBUG INFO</div>
                        <div id="debugInfo" class="debug-info">Waiting for detection...</div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel: Image Display Only -->
            <div class="right-panel">
                <!-- Image Display -->
                <div class="image-display">
                    <img id="expressionImage" class="expression-image" src="" alt="No expression detected">
                </div>
            </div>
        </div>
        
        <!-- Bottom Panels: Expression Images (left) + Presets/Controls (right) -->
        <div class="bottom-panels">
            <!-- Left Panel: Expression Images Management -->
            <div class="left-panel">
                <div class="expression-section">
                    <div class="section-title">
                        EXPRESSION IMAGES
                        <button id="toggleFilter" class="filter-toggle" onclick="toggleExpressionFilter()">SHOW ALL</button>
                    </div>
                    <div id="expressionGrid"></div>
                </div>
            </div>
            
            <!-- Right Panel: Presets + Controls -->
            <div class="right-panel">
                <div class="expression-section">
                    <div class="section-title">PRESET PROFILES</div>
                    <div class="controls-row">
                        <input type="text" id="presetNameInput" placeholder="Preset name..." style="flex: 1; padding: 8px; background: #000000; color: #00ff00; border: 1px solid #00ff00; margin-right: 5px;">
                        <button id="savePresetBtn">SAVE</button>
                    </div>
                    <div id="presetList"></div>
                </div>
                
                <div class="controls-section">
                    <div class="section-title">CONTROLS</div>
                    <div class="controls-row">
                        <button id="clearImagesBtn" class="clear-button">CLEAR ALL IMAGES</button>
                    </div>
                    <div id="loadStatus" class="status">Ready</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Configuration
        const API_BASE_URL = 'http://localhost:8001';
        const WS_BASE_URL = 'ws://localhost:8001';
        const PROCESS_INTERVAL = 100;

        // Global variables
        let video = null;
        let canvas = null;
        let ws = null;
        let isProcessing = false;
        let processingInterval = null;
        let availableExpressions = [];
        let sessionId = Math.random().toString(36).substr(2, 9);
        let lastExpressionImage = null; // Keep track of last expression image
        let showOnlyLoadedExpressions = false;
        let showOverlay = false; // Track overlay visibility
        let currentLoadedExpressions = null; // Store current loaded expressions data

        // DOM elements
        const videoElement = document.getElementById('videoElement');
        const expressionImage = document.getElementById('expressionImage');
        const statusElement = document.getElementById('statusElement');
        // const expressionStatus = document.getElementById('expressionStatus'); // Element doesn't exist
        const debugInfo = document.getElementById('debugInfo');
        const startCameraBtn = document.getElementById('startCameraBtn');
        const startDetectionBtn = document.getElementById('startDetectionBtn');
        const stopDetectionBtn = document.getElementById('stopDetectionBtn');
        const expressionGrid = document.getElementById('expressionGrid');
        const clearImagesBtn = document.getElementById('clearImagesBtn');
        const loadStatus = document.getElementById('loadStatus');
        const presetNameInput = document.getElementById('presetNameInput');
        const savePresetBtn = document.getElementById('savePresetBtn');
        const presetList = document.getElementById('presetList');
        const overlayElement = document.getElementById('overlayElement');
        const toggleOverlayBtn = document.getElementById('toggleOverlayBtn');
        const viewMode = document.getElementById('viewMode');

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async () => {
            await initializeApp();
        });

        async function initializeApp() {
            try {
                updateStatus('Initializing...', 'info');
                
                // Create canvas for frame capture
                canvas = document.createElement('canvas');
                
                // Set up event listeners
                startCameraBtn.addEventListener('click', initializeCamera);
                startDetectionBtn.addEventListener('click', startDetection);
                stopDetectionBtn.addEventListener('click', stopDetection);
                clearImagesBtn.addEventListener('click', clearAllImages);
                savePresetBtn.addEventListener('click', savePreset);
                toggleOverlayBtn.addEventListener('click', toggleOverlay);
                
                updateStatus('Ready', 'success');
            } catch (error) {
                console.error('Failed to initialize app:', error);
                updateStatus(`Initialization failed: ${error.message}`, 'error');
            }
        }

        async function initializeCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 480 },
                        height: { ideal: 360 },
                        frameRate: { ideal: 15 },
                        facingMode: 'user'
                    }
                });
                
                videoElement.srcObject = stream;
                video = videoElement;
                
                startCameraBtn.textContent = 'CAMERA ACTIVE';
                startCameraBtn.disabled = true;
                startDetectionBtn.disabled = false;
                
                updateStatus('Camera ready', 'success');
            } catch (error) {
                console.error('Camera error:', error);
                updateStatus(`Camera error: ${error.message}`, 'error');
            }
        }

        async function startDetection() {
            if (!video || !canvas) {
                updateStatus('Camera not ready', 'error');
                return;
            }
            
            try {
                // Connect to WebSocket
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    ws = new WebSocket(`${WS_BASE_URL}/ws/${sessionId}`);
                    
                    ws.onopen = () => {
                        updateStatus('Connected to backend', 'success');
                        debugInfo.textContent = 'Detection starting...\nWaiting for results...';
                        startProcessing();
                        loadExpressions();
                        loadPresets(); // Load available presets
                    };
                    
                    ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    };
                    
                    ws.onclose = () => {
                        updateStatus('Disconnected from backend', 'error');
                        stopDetection();
                    };
                    
                    ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        updateStatus('Connection error', 'error');
                    };
                } else {
                    startProcessing();
                }
                
            } catch (error) {
                console.error('Detection start error:', error);
                updateStatus(`Detection start failed: ${error.message}`, 'error');
            }
        }

        function startProcessing() {
            isProcessing = true;
            startDetectionBtn.disabled = true;
            stopDetectionBtn.disabled = false;
            
            updateStatus('Detection started', 'success');
            
            // Start processing frames
            processingInterval = setInterval(processFrame, PROCESS_INTERVAL);
            
            console.log('Detection started');
        }

        function stopDetection() {
            isProcessing = false;
            startDetectionBtn.disabled = false;
            stopDetectionBtn.disabled = true;
            
            if (processingInterval) {
                clearInterval(processingInterval);
                processingInterval = null;
            }
            
            if (ws) {
                ws.close();
                ws = null;
            }
            
            updateStatus('Detection stopped', 'info');
            
            console.log('Detection stopped');
        }

        async function processFrame() {
            if (!video || !canvas || !ws || ws.readyState !== WebSocket.OPEN) {
                return;
            }
            
            try {
                // Capture frame from video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d', { alpha: false });
                
                // Draw the video frame
                ctx.drawImage(video, 0, 0);
                
                // Convert canvas to base64
                const frameData = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                
                // Send frame to backend
                ws.send(JSON.stringify({
                    type: 'frame',
                    data: frameData
                }));
                
            } catch (error) {
                console.error('Frame processing error:', error);
            }
        }

        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'detection_result':
                    updateDisplay(data);
                    break;
                case 'expressions':
                    availableExpressions = data.expressions || [];
                    createExpressionControls();
                    loadImageStatus(data.loaded_expressions || {});
                    break;
                case 'status':
                    updateStatus(data.message, 'success');
                    break;
                case 'error':
                    updateStatus(data.message, 'error');
                    break;
                case 'upload_success':
                    updateStatus(data.message, 'success');
                    loadExpressions(); // Refresh status
                    break;
                case 'clear_success':
                    updateStatus(data.message, 'success');
                    loadExpressions(); // Refresh status
                    break;
            }
        }

        function updateDisplay(result) {
            // Update expression image
            if (result.expression_image) {
                lastExpressionImage = `data:image/jpeg;base64,${result.expression_image}`;
                expressionImage.src = lastExpressionImage;
                expressionImage.style.display = 'block';
            } else if (lastExpressionImage) {
                // Keep showing the last expression image even if no new one is detected
                expressionImage.src = lastExpressionImage;
                expressionImage.style.display = 'block';
            } else {
                expressionImage.style.display = 'none';
            }
            
            // Update overlay if available and overlay is enabled
            if (showOverlay && result.frame_with_overlay) {
                overlayElement.src = `data:image/jpeg;base64,${result.frame_with_overlay}`;
            }
            
            // Get expression for debug info - use detected expression from debug data if available
            const expression = (result.debug && result.debug.detected_expression) || result.expression || 'None';
            
            // Update debug info - always show something useful
            console.log('Full result:', result); // Debug logging
            console.log('Debug data:', result.debug); // Debug logging
            
            if (result.debug && result.debug.face_detected !== undefined) {
                const debugText = formatDebugInfo(result.debug, expression);
                debugInfo.textContent = debugText;
            } else {
                // Show what we have available
                let info = `EXPRESSION: ${expression.toUpperCase()}\n`;
                info += `STATUS: Detection active\n`;
                info += `DEBUG DATA: ${result.debug ? 'Present' : 'Missing'}\n`;
                if (result.success !== undefined) {
                    info += `SUCCESS: ${result.success ? 'YES' : 'NO'}\n`;
                }
                debugInfo.textContent = info;
            }
        }

        function formatDebugInfo(debug, currentExpression) {
            let info = '';
            
            if (debug.face_detected) {
                info += `FACE: DETECTED\n`;
                info += `EXPRESSION: ${currentExpression || 'None'}\n`;
                
                // Fix smile detection display
                const smileDetected = debug.smile_result?.is_smiling || false;
                info += `SMILE: ${smileDetected ? 'YES' : 'NO'}\n`;
                
                // Fix mouth open display
                const mouthOpen = debug.mouth_result?.is_mouth_open || false;
                info += `MOUTH OPEN: ${mouthOpen ? 'YES' : 'NO'}\n`;
                
                // Fix gaze direction display
                const gazeDirection = debug.gaze_result?.direction || 'CENTER';
                info += `GAZE: ${gazeDirection.toUpperCase()}\n`;
                
                // Fix hand gesture display
                const handResult = debug.hand_result || {};
                if (handResult.left_hand && handResult.left_hand !== 'None') {
                    info += `LEFT HAND: ${handResult.left_hand.toUpperCase()}\n`;
                }
                if (handResult.right_hand && handResult.right_hand !== 'None') {
                    info += `RIGHT HAND: ${handResult.right_hand.toUpperCase()}\n`;
                }
                if (handResult.special_gesture && handResult.special_gesture !== 'None') {
                    info += `SPECIAL: ${handResult.special_gesture.toUpperCase()}\n`;
                }
                
                // Fix hands data display
                if (debug.hands_data && debug.hands_data.length > 0) {
                    info += `\nHANDS DETECTED: ${debug.hands_data.length}\n`;
                    debug.hands_data.forEach((hand, i) => {
                        info += `HAND ${i+1}: ${hand.label} - ${hand.gesture}\n`;
                    });
                }
            } else {
                info += 'FACE: NOT DETECTED\n';
                info += 'WAITING FOR CAMERA...';
            }
            
            return info;
        }

        function createExpressionControls(loadedExpressions = null) {
            expressionGrid.innerHTML = '';
            
            // If loadedExpressions is provided, filter to only show expressions with images
            let expressionsToShow = availableExpressions;
            if (loadedExpressions && typeof loadedExpressions === 'object') {
                expressionsToShow = availableExpressions.filter(expression => loadedExpressions[expression] === true);
            }
            
            // Define expression categories and their order
            const expressionCategories = {
                'FACIAL EXPRESSIONS': [
                    'smiling',
                    'shocked'
                ],
                'EYE EXPRESSIONS': [
                    'eyes_open',
                    'eyes_closed',
                    'eyes_closed_smiling',
                    'eyes_open_smiling',
                    'eyes_closed_neutral'
                ],
                'GAZE DIRECTIONS': [
                    'looking_left',
                    'looking_right',
                    'looking_center',
                    'looking_left_smiling',
                    'looking_right_smiling',
                    'looking_center_smiling'
                ],
                'HAND GESTURES': [
                    'thumbs_up',
                    'thumbs_down',
                    'open_hand',
                    'fist',
                    'pointing',
                    'one_finger_raised',
                    'one_finger_middle',
                    'one_finger_ring',
                    'one_finger_pinky'
                ],
                'SPECIAL HAND POSITIONS': [
                    'one_hand_raised',
                    'both_hands_raised',
                    'hand_touching_head',
                    'both_hands_thumbs_up',
                    'both_hands_fists'
                ]
            };
            
            // Create sections for each category
            Object.entries(expressionCategories).forEach(([categoryName, expressions]) => {
                // Filter expressions for this category that should be shown
                const categoryExpressions = expressions.filter(expression => expressionsToShow.includes(expression));
                
                if (categoryExpressions.length > 0) {
                    // Create category header
                    const categoryHeader = document.createElement('div');
                    categoryHeader.className = 'category-header';
                    categoryHeader.textContent = categoryName;
                    expressionGrid.appendChild(categoryHeader);
                    
                    // Add expressions from this category
                    categoryExpressions.forEach(expression => {
                        const item = document.createElement('div');
                        item.className = 'expression-item';
                        
                        item.innerHTML = `
                            <span class="expression-name">${formatExpressionName(expression)}</span>
                            <input type="file" id="file-${expression}" accept="image/*" />
                            <button class="file-button" onclick="document.getElementById('file-${expression}').click()">CHOOSE</button>
                            <span id="status-${expression}" class="expression-status">NOT SET</span>
                        `;
                        
                        // Add event listener for file change
                        const fileInput = item.querySelector(`#file-${expression}`);
                        fileInput.addEventListener('change', function() {
                            uploadImage(expression, this);
                        });
                        
                        expressionGrid.appendChild(item);
                    });
                }
            });
            
            // Add any remaining expressions not in categories
            const categorizedExpressions = Object.values(expressionCategories).flat();
            const uncategorizedExpressions = expressionsToShow.filter(expr => !categorizedExpressions.includes(expr));
            
            if (uncategorizedExpressions.length > 0) {
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'category-header';
                categoryHeader.textContent = 'OTHER EXPRESSIONS';
                expressionGrid.appendChild(categoryHeader);
                
                uncategorizedExpressions.forEach(expression => {
                    const item = document.createElement('div');
                    item.className = 'expression-item';
                    
                    item.innerHTML = `
                        <span class="expression-name">${formatExpressionName(expression)}</span>
                        <input type="file" id="file-${expression}" accept="image/*" />
                        <button class="file-button" onclick="document.getElementById('file-${expression}').click()">CHOOSE</button>
                        <span id="status-${expression}" class="expression-status">NOT SET</span>
                    `;
                    
                    // Add event listener for file change
                    const fileInput = item.querySelector(`#file-${expression}`);
                    fileInput.addEventListener('change', function() {
                        uploadImage(expression, this);
                    });
                    
                    expressionGrid.appendChild(item);
                });
            }
        }

        function formatExpressionName(expression) {
            return expression.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        async function fetchLoadedExpressions() {
            try {
                const response = await fetch(`${API_BASE_URL}/loaded_expressions?session_id=${sessionId}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        // Store the loaded expressions data
                        currentLoadedExpressions = data.loaded_expressions || {};
                        loadImageStatus(currentLoadedExpressions);
                    }
                }
            } catch (error) {
                console.error('Failed to fetch loaded expressions:', error);
            }
        }

        function loadImageStatus(loadedExpressions) {
            // If no loadedExpressions provided, fetch from server
            if (!loadedExpressions) {
                fetchLoadedExpressions();
                return;
            }
            
            // Safety check for loadedExpressions
            if (!loadedExpressions || typeof loadedExpressions !== 'object') {
                console.warn('Invalid loadedExpressions data:', loadedExpressions);
                return;
            }
            
            console.log('loadImageStatus called with:', JSON.stringify(loadedExpressions, null, 2));
            
            // Store the loaded expressions data for use in toggle
            currentLoadedExpressions = loadedExpressions;
            
            // Recreate expression controls with filtered expressions (only show those with images)
            if (showOnlyLoadedExpressions) {
                createExpressionControls(loadedExpressions);
            } else {
                createExpressionControls();
            }
            
            Object.keys(loadedExpressions).forEach(expression => {
                const statusElement = document.getElementById(`status-${expression}`);
                if (statusElement) {
                    statusElement.textContent = loadedExpressions[expression] ? 'SET ✓' : 'NOT SET';
                    statusElement.className = 'expression-status';
                }
            });
        }
        
        function toggleExpressionFilter() {
            showOnlyLoadedExpressions = !showOnlyLoadedExpressions;
            const toggleButton = document.getElementById('toggleFilter');
            
            console.log('Toggle filter - showOnlyLoadedExpressions:', showOnlyLoadedExpressions);
            console.log('Current loaded expressions:', JSON.stringify(currentLoadedExpressions, null, 2));
            
            if (showOnlyLoadedExpressions) {
                toggleButton.textContent = 'SHOW ALL';
                // Show only expressions with images using stored data
                if (currentLoadedExpressions) {
                    // Filter to only show expressions that have images assigned
                    const filteredExpressions = {};
                    Object.keys(currentLoadedExpressions).forEach(expression => {
                        console.log(`Expression ${expression}: ${currentLoadedExpressions[expression]}`);
                        if (currentLoadedExpressions[expression]) {
                            filteredExpressions[expression] = currentLoadedExpressions[expression];
                        }
                    });
                    console.log('Filtered expressions:', JSON.stringify(filteredExpressions, null, 2));
                    createExpressionControls(filteredExpressions);
                    // Update status for visible expressions
                    Object.keys(filteredExpressions).forEach(expression => {
                        const statusElement = document.getElementById(`status-${expression}`);
                        if (statusElement) {
                            statusElement.textContent = 'SET ✓';
                            statusElement.className = 'expression-status';
                        }
                    });
                } else {
                    console.log('No currentLoadedExpressions, fetching from server');
                    // Fallback: fetch from server
                    fetchLoadedExpressions();
                }
            } else {
                toggleButton.textContent = 'FILTERED';
                // Show all expressions
                createExpressionControls();
                // Update status for all expressions if we have data
                if (currentLoadedExpressions) {
                    Object.keys(currentLoadedExpressions).forEach(expression => {
                        const statusElement = document.getElementById(`status-${expression}`);
                        if (statusElement) {
                            statusElement.textContent = currentLoadedExpressions[expression] ? 'SET ✓' : 'NOT SET';
                            statusElement.className = 'expression-status';
                        }
                    });
                }
            }
        }

        async function uploadImage(expression, input) {
            const file = input.files[0];
            if (!file) {
                return;
            }
            
            try {
                // Convert file to base64
                const reader = new FileReader();
                reader.onload = function() {
                    const base64Data = reader.result.split(',')[1];
                    
                    // Send to backend
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'upload_image',
                            expression_type: expression,
                            image_data: base64Data
                        }));
                    }
                };
                reader.readAsDataURL(file);
                
                // Show uploading status
                const statusElement = document.getElementById(`status-${expression}`);
                if (statusElement) {
                    statusElement.textContent = 'UPLOADING...';
                    statusElement.className = 'expression-status';
                }
                
            } catch (error) {
                console.error('Upload error:', error);
                updateStatus(`Upload failed: ${error.message}`, 'error');
            }
            
            // Clear the input
            input.value = '';
        }

        async function loadExpressions() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'get_expressions'
                }));
            }
        }

        async function clearAllImages() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'clear_images'
                }));
            }
            // Also clear the displayed expression image
            lastExpressionImage = null;
            expressionImage.style.display = 'none';
        }


        async function savePreset() {
            const presetName = presetNameInput.value.trim();
            if (!presetName) {
                updateStatus('Please enter a preset name', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/presets/${encodeURIComponent(presetName)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: sessionId
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    updateStatus(`Preset '${presetName}' saved successfully`, 'success');
                    presetNameInput.value = '';
                    loadPresets(); // Refresh preset list
                } else {
                    updateStatus(`Failed to save preset: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('Save preset error:', error);
                updateStatus(`Save failed: ${error.message}`, 'error');
            }
        }

        async function loadPreset(presetName) {
            try {
                const response = await fetch(`${API_BASE_URL}/presets/${encodeURIComponent(presetName)}/load`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: sessionId
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    updateStatus(`Preset '${presetName}' loaded successfully`, 'success');
                    
                    // Enable filtered view when loading a preset
                    showOnlyLoadedExpressions = true;
                    const toggleButton = document.getElementById('toggleFilter');
                    toggleButton.textContent = 'SHOW ALL';
                    
                    loadImageStatus(); // Refresh image status
                } else {
                    updateStatus(`Failed to load preset: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('Load preset error:', error);
                updateStatus(`Load failed: ${error.message}`, 'error');
            }
        }

        async function deletePreset(presetName) {
            if (!confirm(`Are you sure you want to delete preset '${presetName}'?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE_URL}/presets/${encodeURIComponent(presetName)}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    updateStatus(`Preset '${presetName}' deleted successfully`, 'success');
                    loadPresets(); // Refresh preset list
                } else {
                    updateStatus(`Failed to delete preset: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('Delete preset error:', error);
                updateStatus(`Delete failed: ${error.message}`, 'error');
            }
        }

        async function loadPresets() {
            try {
                const response = await fetch(`${API_BASE_URL}/presets`);
                
                if (!response.ok) {
                    throw new Error('Failed to load presets');
                }
                
                const result = await response.json();
                
                if (result.success) {
                    displayPresets(result.presets);
                } else {
                    console.error('Failed to load presets:', result.error);
                }
                
            } catch (error) {
                console.error('Load presets error:', error);
            }
        }

        function displayPresets(presets) {
            presetList.innerHTML = '';
            
            // Add safety check for presets array
            if (!presets || !Array.isArray(presets) || presets.length === 0) {
                presetList.innerHTML = '<div class="status">No presets available</div>';
                return;
            }
            
            presets.forEach(preset => {
                // Add safety checks for preset properties
                if (!preset || !preset.name) {
                    console.warn('Invalid preset data:', preset);
                    return;
                }
                
                const presetItem = document.createElement('div');
                presetItem.className = 'expression-item';
                
                presetItem.innerHTML = `
                    <span class="expression-name">${preset.name}</span>
                    <span class="expression-status">${preset.total_images || 0} images</span>
                    <button class="file-button" onclick="loadPreset('${preset.name}')">LOAD</button>
                    <button class="file-button clear-button" onclick="deletePreset('${preset.name}')">DELETE</button>
                `;
                
                presetList.appendChild(presetItem);
            });
        }

        function updateStatus(message, type = 'info') {
            statusElement.textContent = message.toUpperCase();
            statusElement.className = `status ${type}`;
        }

        function toggleOverlay() {
            showOverlay = !showOverlay;
            if (showOverlay) {
                overlayElement.style.display = 'block';
                toggleOverlayBtn.textContent = 'HIDE OVERLAY';
                viewMode.textContent = 'Detection Overlay';
            } else {
                overlayElement.style.display = 'none';
                toggleOverlayBtn.textContent = 'SHOW OVERLAY';
                viewMode.textContent = 'Raw Camera';
            }
        }
    </script>
</body>
</html>


